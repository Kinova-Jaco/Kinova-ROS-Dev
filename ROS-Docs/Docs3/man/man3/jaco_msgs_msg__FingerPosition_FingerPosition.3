.TH "jaco_msgs.msg._FingerPosition.FingerPosition" 3 "Thu Mar 3 2016" "Version 1.0.1" "Kinova-ROS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
jaco_msgs.msg._FingerPosition.FingerPosition \- 
.SH SYNOPSIS
.br
.PP
.PP
Inherits Message\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "def \fB__init__\fP (self, args, kwds)"
.br
.ti -1c
.RI "def \fBdeserialize\fP (self, str)"
.br
.ti -1c
.RI "def \fBdeserialize_numpy\fP (self, str, numpy)"
.br
.ti -1c
.RI "def \fBserialize\fP (self, buff)"
.br
.ti -1c
.RI "def \fBserialize_numpy\fP (self, buff, numpy)"
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fBfinger1\fP"
.br
.ti -1c
.RI "\fBfinger2\fP"
.br
.ti -1c
.RI "\fBfinger3\fP"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "def \fB_get_types\fP (self)"
.br
.in -1c
.SS "Static Private Attributes"

.in +1c
.ti -1c
.RI "list \fB__slots__\fP = ['\fBfinger1\fP','\fBfinger2\fP','\fBfinger3\fP']"
.br
.ti -1c
.RI "string \fB_full_text\fP"
.br
.ti -1c
.RI "bool \fB_has_header\fP = False"
.br
.ti -1c
.RI "string \fB_md5sum\fP = 'f56891e5dcd1900989f764a9b845c8e5'"
.br
.ti -1c
.RI "list \fB_slot_types\fP = ['float32','float32','float32']"
.br
.ti -1c
.RI "string \fB_type\fP = 'jaco_msgs/\fBFingerPosition\fP'"
.br
.in -1c
.SH "Detailed Description"
.PP 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "def jaco_msgs\&.msg\&._FingerPosition\&.FingerPosition\&.__init__ ( self,  args,  kwds)"

.PP
.nf
Constructor. Any message fields that are implicitly/explicitly
set to None will be assigned a default value. The recommend
use is keyword arguments as this is more robust to future message
changes.  You cannot mix in-order arguments and keyword arguments.

The available fields are:
   finger1,finger2,finger3

:param args: complete set of field values, in .msg order
:param kwds: use keyword arguments corresponding to message field names
to set specific fields.

.fi
.PP
 
.PP
.nf
20   def __init__(self, *args, **kwds):
21     """
22     Constructor\&. Any message fields that are implicitly/explicitly
23     set to None will be assigned a default value\&. The recommend
24     use is keyword arguments as this is more robust to future message
25     changes\&.  You cannot mix in-order arguments and keyword arguments\&.
26 
27     The available fields are:
28        finger1,finger2,finger3
29 
30     :param args: complete set of field values, in \&.msg order
31     :param kwds: use keyword arguments corresponding to message field names
32     to set specific fields\&.
33     """
34     if args or kwds:
35       super(FingerPosition, self)\&.__init__(*args, **kwds)
36       #message fields cannot be None, assign default values for those that are
37       if self\&.finger1 is None:
38         self\&.finger1 = 0\&.
39       if self\&.finger2 is None:
40         self\&.finger2 = 0\&.
41       if self\&.finger3 is None:
42         self\&.finger3 = 0\&.
43     else:
44       self\&.finger1 = 0\&.
45       self\&.finger2 = 0\&.
46       self\&.finger3 = 0\&.
47 
.fi
.SH "Member Function Documentation"
.PP 
.SS "def jaco_msgs\&.msg\&._FingerPosition\&.FingerPosition\&._get_types ( self)\fC [private]\fP"

.PP
.nf
internal API method

.fi
.PP
 
.PP
.nf
48   def _get_types(self):
49     """
50     internal API method
51     """
52     return self\&._slot_types
53 
.fi
.SS "def jaco_msgs\&.msg\&._FingerPosition\&.FingerPosition\&.deserialize ( self,  str)"

.PP
.nf
unpack serialized message in str into this message instance
:param str: byte array of serialized message, ``str``

.fi
.PP
 
.PP
.nf
65   def deserialize(self, str):
66     """
67     unpack serialized message in str into this message instance
68     :param str: byte array of serialized message, ``str``
69     """
70     try:
71       end = 0
72       _x = self
73       start = end
74       end += 12
75       (_x\&.finger1, _x\&.finger2, _x\&.finger3,) = _struct_3f\&.unpack(str[start:end])
76       return self
77     except struct\&.error as e:
78       raise genpy\&.DeserializationError(e) #most likely buffer underfill
79 
80 
.fi
.SS "def jaco_msgs\&.msg\&._FingerPosition\&.FingerPosition\&.deserialize_numpy ( self,  str,  numpy)"

.PP
.nf
unpack serialized message in str into this message instance using numpy for array types
:param str: byte array of serialized message, ``str``
:param numpy: numpy python module

.fi
.PP
 
.PP
.nf
93   def deserialize_numpy(self, str, numpy):
94     """
95     unpack serialized message in str into this message instance using numpy for array types
96     :param str: byte array of serialized message, ``str``
97     :param numpy: numpy python module
98     """
99     try:
100       end = 0
101       _x = self
102       start = end
103       end += 12
104       (_x\&.finger1, _x\&.finger2, _x\&.finger3,) = _struct_3f\&.unpack(str[start:end])
105       return self
106     except struct\&.error as e:
107       raise genpy\&.DeserializationError(e) #most likely buffer underfill
108 
.fi
.SS "def jaco_msgs\&.msg\&._FingerPosition\&.FingerPosition\&.serialize ( self,  buff)"

.PP
.nf
serialize message into buffer
:param buff: buffer, ``StringIO``

.fi
.PP
 
.PP
.nf
54   def serialize(self, buff):
55     """
56     serialize message into buffer
57     :param buff: buffer, ``StringIO``
58     """
59     try:
60       _x = self
61       buff\&.write(_struct_3f\&.pack(_x\&.finger1, _x\&.finger2, _x\&.finger3))
62     except struct\&.error as se: self\&._check_types(struct\&.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(_x))))
63     except TypeError as te: self\&._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(_x))))
64 
.fi
.SS "def jaco_msgs\&.msg\&._FingerPosition\&.FingerPosition\&.serialize_numpy ( self,  buff,  numpy)"

.PP
.nf
serialize message with numpy array types into buffer
:param buff: buffer, ``StringIO``
:param numpy: numpy python module

.fi
.PP
 
.PP
.nf
81   def serialize_numpy(self, buff, numpy):
82     """
83     serialize message with numpy array types into buffer
84     :param buff: buffer, ``StringIO``
85     :param numpy: numpy python module
86     """
87     try:
88       _x = self
89       buff\&.write(_struct_3f\&.pack(_x\&.finger1, _x\&.finger2, _x\&.finger3))
90     except struct\&.error as se: self\&._check_types(struct\&.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(_x))))
91     except TypeError as te: self\&._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(_x))))
92 
.fi
.SH "Member Data Documentation"
.PP 
.SS "list jaco_msgs\&.msg\&._FingerPosition\&.FingerPosition\&.__slots__ = ['\fBfinger1\fP','\fBfinger2\fP','\fBfinger3\fP']\fC [static]\fP, \fC [private]\fP"

.SS "string jaco_msgs\&.msg\&._FingerPosition\&.FingerPosition\&._full_text\fC [static]\fP, \fC [private]\fP"
\fBInitial value:\fP
.PP
.nf
1 = """float32 finger1
2 float32 finger2
3 float32 finger3
4 
5 """
.fi
.SS "bool jaco_msgs\&.msg\&._FingerPosition\&.FingerPosition\&._has_header = False\fC [static]\fP, \fC [private]\fP"

.SS "string jaco_msgs\&.msg\&._FingerPosition\&.FingerPosition\&._md5sum = 'f56891e5dcd1900989f764a9b845c8e5'\fC [static]\fP, \fC [private]\fP"

.SS "list jaco_msgs\&.msg\&._FingerPosition\&.FingerPosition\&._slot_types = ['float32','float32','float32']\fC [static]\fP, \fC [private]\fP"

.PP
Referenced by jaco_msgs\&.msg\&._FingerPosition\&.FingerPosition\&._get_types()\&.
.SS "string jaco_msgs\&.msg\&._FingerPosition\&.FingerPosition\&._type = 'jaco_msgs/\fBFingerPosition\fP'\fC [static]\fP, \fC [private]\fP"

.SS "jaco_msgs\&.msg\&._FingerPosition\&.FingerPosition\&.finger1"

.PP
Referenced by jaco_msgs\&.msg\&._FingerPosition\&.FingerPosition\&.__init__()\&.
.SS "jaco_msgs\&.msg\&._FingerPosition\&.FingerPosition\&.finger2"

.SS "jaco_msgs\&.msg\&._FingerPosition\&.FingerPosition\&.finger3"


.SH "Author"
.PP 
Generated automatically by Doxygen for Kinova-ROS from the source code\&.
