.TH "D:/Longfei/Desktop/catkin_KinovaROS/src/jaco-ros/jaco_driver/include/kinova/KinovaTypes.h" 3 "Thu Mar 3 2016" "Version 1.0.1" "Kinova-ROS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
D:/Longfei/Desktop/catkin_KinovaROS/src/jaco-ros/jaco_driver/include/kinova/KinovaTypes.h \- This file contains all data structures and all data type(enum and typedef) that you'll need to use this API\&.  

.SH SYNOPSIS
.br
.PP
.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBAngularAcceleration\fP"
.br
.RI "\fIThis data structure holds acceleration values(X, Y, Z) in an angular(joint by joint) control context\&. \fP"
.ti -1c
.RI "struct \fBAngularInfo\fP"
.br
.RI "\fIThis data structure holds values in an angular(joint by joint) control context\&. As an example struct could contains position, temperature, torque, \&.\&.\&. \fP"
.ti -1c
.RI "struct \fBAngularPosition\fP"
.br
.RI "\fIThis data structure holds the values of an angular(actuators) position\&. \fP"
.ti -1c
.RI "struct \fBButtonEvents\fP"
.br
.RI "\fIThis is an event from a controller's button\&. Each variable of the struct can be mapped with a ControlFunctionalityTypeEnum\&. \fP"
.ti -1c
.RI "struct \fBCartesianInfo\fP"
.br
.RI "\fIThis data structure holds values in an cartesian control context\&. \fP"
.ti -1c
.RI "struct \fBCartesianPosition\fP"
.br
.RI "\fIThis data structure holds the values of a cartesian position\&. \fP"
.ti -1c
.RI "struct \fBClientConfigurations\fP"
.br
.RI "\fIThis structure holds informations relative to the client\&. It is mostly used for rehab clients\&. As an example, if you need to modify the max velocity or the retract position, it will be done here\&. The easiest way to modify the client configuration is to get the current one by calling the function GetClientConfigurations, modify all the parameters you need and send the structure back to the robot by calling the function \fBSetClientConfigurations()\fP\&. Note that some of the parameters are read only\&. That means that even if you modify them and send the structure to the robot, they will not be modified\&. \fP"
.ti -1c
.RI "struct \fBControlMapping\fP"
.br
.RI "\fIThis represents a group of functionalities mapped to some events triggered by a specific controller\&. \fP"
.ti -1c
.RI "struct \fBControlMappingCharts\fP"
.br
.RI "\fIThis structure holds all the control mapping of the system\&. It is the entry point if you want to use the mapping system\&. \fP"
.ti -1c
.RI "struct \fBControlsModeMap\fP"
.br
.RI "\fIRepresents one mode map of a control mapping\&. Each control mapping has 2 list of mode map\&. \fP"
.ti -1c
.RI "struct \fBFinger\fP"
.br
.RI "\fIStructure that represents a finger from the end effector's tool\&. \fP"
.ti -1c
.RI "struct \fBFingersPosition\fP"
.br
.RI "\fIThis data structure holds the values of the robot's fingers\&. \fP"
.ti -1c
.RI "struct \fBForcesInfo\fP"
.br
.RI "\fIThis structure contains informations about the torque and the force of the robotical arm\&. \fP"
.ti -1c
.RI "struct \fBGeneralInformations\fP"
.br
.RI "\fIThis is structure hold almost all information of the robotical arm\&. \fP"
.ti -1c
.RI "struct \fBGripper\fP"
.br
.RI "\fIStructure that represents the robotical arm's gripper\&. \fP"
.ti -1c
.RI "struct \fBJoystickCommand\fP"
.br
.RI "\fIThis is a virtual representation of a 6-axis joystick\&. \fP"
.ti -1c
.RI "struct \fBLimitation\fP"
.br
.RI "\fIThis data structure represents all limitation that can be applied to a control context\&. \fP"
.ti -1c
.RI "struct \fBPeripheralInfo\fP"
.br
.RI "\fIThis data structure holds information that describes an abstract peripheral\&. \fP"
.ti -1c
.RI "struct \fBQuickStatus\fP"
.br
.RI "\fIThis structure holds various informations but mostly it is flag status\&. \fP"
.ti -1c
.RI "struct \fBSensorsInfo\fP"
.br
.RI "\fIThis data structure holds the values of the robot's sensors\&. \fP"
.ti -1c
.RI "struct \fBSingularityVector\fP"
.br
.RI "\fIThis data structure represents the informations regarding the singularities surrounding the end effector\&. It is not used for now but will be in the future\&. \fP"
.ti -1c
.RI "struct \fBStickEvents\fP"
.br
.RI "\fIThis is an event from a controller's stick\&. Each variable of the struct can be mapped with a ControlFunctionalityTypeEnum\&. \fP"
.ti -1c
.RI "struct \fBSystemError\fP"
.br
.RI "\fIThis represents a system error\&. Every error generated by the system is logged in the robot's flash memory\&. \fP"
.ti -1c
.RI "struct \fBSystemStatus\fP"
.br
.RI "\fIThis structure holds system status flags\&. \fP"
.ti -1c
.RI "struct \fBTrajectoryFIFO\fP"
.br
.RI "\fIThis data structure represents the informations regarding the robot's trajectory's FIFO\&. \fP"
.ti -1c
.RI "struct \fBTrajectoryPoint\fP"
.br
.RI "\fIThis data structure represents a point of a trajectory\&. It contains the position a limitation that you can applied\&. \fP"
.ti -1c
.RI "struct \fBUserPosition\fP"
.br
.RI "\fIThis data structure represents an abstract position built by a user\&. Depending on the control type the Cartesian information, the angular information or both will be used\&. \fP"
.ti -1c
.RI "struct \fBZone\fP"
.br
.RI "\fIthat represents a protection zone\&. \fP"
.ti -1c
.RI "struct \fBZoneLimitation\fP"
.br
.RI "\fIThis represents a group of limitations that can be applied to a trajectory point\&. \fP"
.ti -1c
.RI "struct \fBZoneList\fP"
.br
.RI "\fIThis structure represents the complete list of protection zone of the robotical arm\&. \fP"
.ti -1c
.RI "struct \fBZoneShape\fP"
.br
.RI "\fIRepresents the 3D shape of a protection zone\&. \fP"
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBBUTTON_EVENT_COUNT\fP   26"
.br
.RI "\fIThis is the size of the array ControlButtons contained in the structure \fBControlsModeMap\fP \&. \fP"
.ti -1c
.RI "#define \fBCONTROL_MAPPING_COUNT\fP   6"
.br
.RI "\fIThis is the size of the array Mapping contained in the structure \fBControlMappingCharts\fP \&. \fP"
.ti -1c
.RI "#define \fBERROR_DATA_COUNT_MAX\fP   50"
.br
.RI "\fIThis is the size of the data array stored in a \fBSystemError\fP object\&. \fP"
.ti -1c
.RI "#define \fBERROR_FILEREADING\fP   5003"
.br
.RI "\fIThis is an error code\&. It means that the function has some problem reading a file\&. Most of the time it is because the user don't have the privileges to do it\&. \fP"
.ti -1c
.RI "#define \fBERROR_LAYER_COUNT\fP   7"
.br
.RI "\fIThe robot's firmware has several software layers\&. This describes how many layer there is in the firmware\&. \fP"
.ti -1c
.RI "#define \fBERROR_MEMORY\fP   5002"
.br
.RI "\fIThis is an error code\&. It means that there was a memory related error\&. Most of the time it is because the system does not have enough memory\&. \fP"
.ti -1c
.RI "#define \fBERROR_UNKNOWFILE\fP   5001"
.br
.RI "\fIThis is an error code\&. It means that the file you are trying to interact with does not exist or is corrupted\&. Either way, the OS does not recognise it\&. \fP"
.ti -1c
.RI "#define \fBJACO_FINGERS_COUNT\fP   3"
.br
.RI "\fIThis is the max finger count in a robot\&. (Jaco has 3 fingers and Mico has 2 fingers) \fP"
.ti -1c
.RI "#define \fBJOYSTICK_BUTTON_COUNT\fP   16"
.br
.RI "\fISize of the \fBControlsModeMap\fP array in the structure \fBJoystickCommand\fP\&. \fP"
.ti -1c
.RI "#define \fBLEGACY_CONFIG_NB_POINTS_COUNT\fP   8"
.br
.RI "\fIThis is the size of the array Points in a \fBZoneShape\fP \&. \fP"
.ti -1c
.RI "#define \fBLEGACY_CONFIG_NB_ZONES_MAX\fP   10"
.br
.RI "\fIThis represents the max count of protection zones that can be stored in the robot's memory\&. \fP"
.ti -1c
.RI "#define \fBMODE_MAP_COUNT\fP   6"
.br
.RI "\fIThis is the size of the arrays ModeControlsA and ModeControlsB contained in the structure \fBControlMapping\fP \&. \fP"
.ti -1c
.RI "#define \fBNB_ADVANCE_RETRACT_POSITION\fP   20"
.br
.RI "\fIMax size of the advance retract trajectory that is stored in the \fBClientConfigurations\fP\&. \fP"
.ti -1c
.RI "#define \fBSTICK_EVENT_COUNT\fP   6"
.br
.RI "\fIThis is the size of the array ControlSticks contained in the structure \fBControlsModeMap\fP \&. \fP"
.ti -1c
.RI "#define \fBSTRING_LENGTH\fP   20"
.br
.RI "\fIThis is the size of all strings stored in the robot's firmware\&. \fP"
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBArmLaterality\fP { \fBRIGHTHAND\fP, \fBLEFTHAND\fP }
.RI "\fIThat indicates if the robot will be left handed or right handed\&. \fP""
.br
.ti -1c
.RI "enum \fBCONTROL_MODULE\fP { \fBCONTROL_MODULE_NONE\fP, \fBCONTROL_MODULE_ANGULAR_VELOCITY\fP, \fBCONTROL_MODULE_ANGULAR_POSITION\fP, \fBCONTROL_MODULE_CARTESIAN_VELOCITY\fP, \fBCONTROL_MODULE_CARTESIAN_POSITION\fP, \fBCONTROL_MODULE_RETRACT\fP, \fBCONTROL_MODULE_TRAJECTORY\fP, \fBCONTROL_MODULE_PREDEFINED\fP, \fBCONTROL_MODULE_TIMEDELAY\fP }
.RI "\fIThat describes a control module of the robotical arm's firmware\&. \fP""
.br
.ti -1c
.RI "enum \fBCONTROL_TYPE\fP { \fBCONTROL_TYPE_CARTESIAN\fP = 0, \fBCONTROL_TYPE_ANGULAR\fP = 1 }
.RI "\fIThis represents a type of control\&. For now, there is 2 type of control, it can either cartesian control or angular control\&. \fP""
.br
.ti -1c
.RI "enum \fBControlFunctionalityTypeEnum\fP { \fBCF_NoFunctionality\fP = 0, \fBCF_Disable_EnableJoystick\fP = 1, \fBCF_Retract_ReadyToUse\fP = 2, \fBCF_Change_TwoAxis_ThreeAxis\fP = 3, \fBCF_Change_DrinkingMode\fP = 4, \fBCF_Cycle_ModeA_list\fP = 5, \fBCF_Cycle_ModeB_list\fP = 6, \fBCF_DecreaseSpeed\fP = 7, \fBCF_IncreaseSpeed\fP = 8, \fBCF_Goto_Position1\fP = 9, \fBCF_Goto_Position2\fP = 10, \fBCF_Goto_Position3\fP = 11, \fBCF_Goto_Position4\fP = 12, \fBCF_Goto_Position5\fP = 13, \fBCF_RecordPosition1\fP = 14, \fBCF_RecordPosition2\fP = 15, \fBCF_RecordPosition3\fP = 16, \fBCF_RecordPosition4\fP = 17, \fBCF_RecordPosition5\fP = 18, \fBCF_X_Positive\fP = 19, \fBCF_X_Negative\fP = 20, \fBCF_Y_Positive\fP = 21, \fBCF_Y_Negative\fP = 22, \fBCF_Z_Positive\fP = 23, \fBCF_Z_Negative\fP = 24, \fBCF_R_Positive\fP = 25, \fBCF_R_Negative\fP = 26, \fBCF_U_Positive\fP = 27, \fBCF_U_Negative\fP = 28, \fBCF_V_Positive\fP = 29, \fBCF_V_Negative\fP = 30, \fBCF_OpenHandOneFingers\fP = 31, \fBCF_CloseHandOneFingers\fP = 32, \fBCF_OpenHandTwoFingers\fP = 33, \fBCF_CloseHandTwoFingers\fP = 34, \fBCF_OpenHandThreeFingers\fP = 35, \fBCF_CloseHandThreeFingers\fP = 36, \fBCF_ForceAngularVelocity\fP = 37, \fBCF_ForceControlStatus\fP = 38, \fBCF_Trajectory\fP = 39, \fBCF_AutomaticOrientationXPlus\fP = 40, \fBCF_AutomaticOrientationXMinus\fP = 41, \fBCF_AutomaticOrientationYPlus\fP = 42, \fBCF_AutomaticOrientationYMinus\fP = 43, \fBCF_AutomaticOrientationZPlus\fP = 44, \fBCF_AutomaticOrientationZMinus\fP = 45, \fBCF_AdvanceGOTO_1\fP = 46, \fBCF_AdvanceGOTO_Clear_1\fP = 47, \fBCF_AdvanceGOTO_Add_1\fP = 48 }
.RI "\fIThis is the list of available feature that can be mapped with a controller through the mappign system\&. Every list of mode that a mapping contains is mapped with one of these features\&. The default value is CF_NoFunctionality\&. \fP""
.br
.ti -1c
.RI "enum \fBController\fP { \fBTHREE_AXIS_JOYSTICK\fP = 0, \fBTWO_AXIS_JOYSTICK\fP = 1, \fBAPI\fP = 2, \fBEASY_RIDER\fP = 3, \fBUNIVERSAL_INTERFACE\fP = 4, \fBEXTERNAL_CUSTOMINTERFACE\fP = 5, \fBNONE\fP = 6, \fBOLED_DISPLAY\fP = 7 }
.RI "\fIThis represents a type of controller\&. A controller is an entity that can send control commands to the robot\&. \fP""
.br
.ti -1c
.RI "enum \fBControlMappingMode\fP { \fBOneAxis\fP, \fBTwoAxis\fP, \fBThreeAxis\fP, \fBSixAxis\fP }
.RI "\fIIndicates the type of controller\&. \fP""
.br
.ti -1c
.RI "enum \fBerrorLoggerType\fP { \fBERROR_NOTINITIALIZED\fP, \fBkeos_err1\fP, \fBkeos_err2\fP, \fBkeos_err3\fP, \fBUser_err_start_marker\fP, \fBerrorlog_Actuator_Temperature\fP, \fBerrorlog_Actuator_TemperatureOK\fP, \fBerrorlog_Finger_Temperature\fP, \fBerrorlog_Finger_TemperatureOK\fP, \fBerrorlog_voltage\fP, \fBerrorlog_voltageOK\fP, \fBerrorlog_current_FingersClosing\fP, \fBerrorlog_current_FingersOpening\fP, \fBerrorlog_current_FingersOK\fP, \fBerrorlog_current_Actuators\fP, \fBerrorlog_current_ActuatorsOK\fP, \fBerrorLog_RobotStatus_Build_Incomplete\fP, \fBerrorLogger_END\fP }
.RI "\fIThat represents the type of an error\&. It is used mostly for identification\&. \fP""
.br
.ti -1c
.RI "enum \fBHAND_MODE\fP { \fBHAND_NOMOVEMENT\fP, \fBPOSITION_MODE\fP, \fBVELOCITY_MODE\fP }
.RI "\fIThat indicates how the end effector will be used\&. \fP""
.br
.ti -1c
.RI "enum \fBPERIPHERAL_TYPE\fP { \fBPERIPHERAL_TYPE_NONE\fP = 0, \fBPERIPHERAL_TYPE_ANY\fP = 1, \fBPERIPHERAL_TYPE_ACTUATORK01\fP = 100, \fBPERIPHERAL_TYPE_FINGERK01\fP = 200, \fBPERIPHERAL_TYPE_JOYSTICK\fP = 300, \fBPERIPHERAL_TYPE_VIRTUAL_JOYSTICK\fP = 301, \fBPERIPHERAL_TYPE_CAN_INTERFACE\fP = 400 }"
.br
.ti -1c
.RI "enum \fBPOSITION_TYPE\fP { \fBNOMOVEMENT_POSITION\fP = 0, \fBCARTESIAN_POSITION\fP = 1, \fBANGULAR_POSITION\fP = 2, \fBCARTESIAN_VELOCITY\fP = 7, \fBANGULAR_VELOCITY\fP = 8, \fBANY_TRAJECTORY\fP = 11, \fBTIME_DELAY\fP = 12 }
.RI "\fIThat represents the type of a position\&. If used during a trajectory, the type of position will change the behaviour of the robot\&. For example if the position type is CARTESIAN_POSITION, then the robot's end effector will move to that position using the inverse kinematics\&. But if the type of position is CARTESIAN_VELOCITY then the robot will use the values as velocity command\&. \fP""
.br
.ti -1c
.RI "enum \fBRETRACT_TYPE\fP { \fBRETRACT_TYPE_NORMAL_TO_READY\fP = 0, \fBRETRACT_TYPE_READY_STANDBY\fP = 1, \fBRETRACT_TYPE_READY_TO_RETRACT\fP = 2, \fBRETRACT_TYPE_RETRACT_STANDBY\fP = 3, \fBRETRACT_TYPE_RETRACT_TO_READY\fP = 4, \fBRETRACT_TYPE_NORMAL_STANDBY\fP = 5, \fBRETRACT_TYPE_NOT_INITIALIZED\fP = 6 }
.RI "\fIThis describes the retract type the robotical arm\&. \fP""
.br
.ti -1c
.RI "enum \fBShapeType\fP { \fBPrismSquareBase_X\fP = 0, \fBPrismSquareBase_Y\fP = 1, \fBPrismSquareBase_Z\fP = 2, \fBPrismTriangularBase_X\fP = 3, \fBPrismTriangularBase_Y\fP = 4, \fBPrismTriangularBase_Z\fP = 5, \fBPyramid\fP = 6 }
.RI "\fIThis represents the type of a 3d shape\&. \fP""
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "const int \fBADDRESS_PAGE_SIZE\fP = 4"
.br
.RI "\fIThis represents the size of a page's address\&. \fP"
.ti -1c
.RI "const unsigned short \fBPACKET_PER_PAGE_QTY\fP = 40"
.br
.RI "\fIThis represents the quantity of USB packet stored in a memory page\&. \fP"
.ti -1c
.RI "const unsigned short \fBPAGE_SIZE\fP = 2048"
.br
.RI "\fIThis represents the size of a memory page used to program the robot\&. \fP"
.ti -1c
.RI "const int \fBPAGEPACKET_SIZE\fP = 52"
.br
.RI "\fIThat represents the data's size of each USB packet during firmware update\&. \fP"
.ti -1c
.RI "const int \fBUSB_DATA_SIZE\fP = 56"
.br
.RI "\fIThat represents the data's size of a normal USB packet\&. \fP"
.ti -1c
.RI "const int \fBUSB_HEADER_SIZE\fP = 8"
.br
.RI "\fIThat represents the size of a USB packet's header\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 
This file contains all data structures and all data type(enum and typedef) that you'll need to use this API\&. 


.PP
Definition in file \fBKinovaTypes\&.h\fP\&.
.SH "Class Documentation"
.PP 
.SH "struct AngularPosition"
.PP 
This data structure holds the values of an angular(actuators) position\&. 
.PP
\fBClass Members:\fP
.RS 4
\fBAngularInfo\fP \fIActuators\fP This contains value regarding the actuators\&. 
.br
.PP
\fBFingersPosition\fP \fIFingers\fP This contains value regarding the actuators\&. 
.br
.PP
.RE
.PP
.SH "struct ButtonEvents"
.PP 
This is an event from a controller's button\&. Each variable of the struct can be mapped with a ControlFunctionalityTypeEnum\&. 
.PP
\fBClass Members:\fP
.RS 4
unsigned char \fIHoldDown\fP Represents a PRESS and HOLD event\&. 
.br
.PP
unsigned char \fIHoldFourSec\fP Represents a PRESS and HOLD for 4 second event\&. 
.br
.PP
unsigned char \fIHoldOneSec\fP Represents a PRESS and HOLD for 1 second event \&. 
.br
.PP
unsigned char \fIHoldThreeSec\fP Represents a PRESS and HOLD for 3 second event\&. 
.br
.PP
unsigned char \fIHoldTwoSec\fP Represents a PRESS and HOLD for 2 second event\&. 
.br
.PP
unsigned char \fIOneClick\fP Represents a single CLICK event\&.(PRESS and RELEASE) 
.br
.PP
unsigned char \fITwoClick\fP Not used for now\&. 
.br
.PP
.RE
.PP
.SH "struct ClientConfigurations"
.PP 
This structure holds informations relative to the client\&. It is mostly used for rehab clients\&. As an example, if you need to modify the max velocity or the retract position, it will be done here\&. The easiest way to modify the client configuration is to get the current one by calling the function GetClientConfigurations, modify all the parameters you need and send the structure back to the robot by calling the function \fBSetClientConfigurations()\fP\&. Note that some of the parameters are read only\&. That means that even if you modify them and send the structure to the robot, they will not be modified\&. 
.PP
\fBClass Members:\fP
.RS 4
char \fIClientID[\fBSTRING_LENGTH\fP]\fP This is the ID of the client\&. The string must ends with a EndOfString character(\\0)\&. 
.br
.PP
char \fIClientName[\fBSTRING_LENGTH\fP]\fP This is the name of the client\&. The string must ends with a EndOfString character(\\0)\&. 
.br
.PP
int \fIComplexRetractActive\fP That flag tells you if the advance retract feature is active\&. (0 = not active, 1 = active) The advance retract mode let you decide the trajectory between the READY(home) position and the retracted position\&. 
.br
.PP
int \fIDeletePreProgrammedPositionsAtRetract\fP It is a flag that indicates if the GOTO(pre programmed) position are deleted when the robot goes in READY position\&. 
.br
.PP
float \fIDrinkingDistance\fP This value is used only when the drinking mode is active\&. This add a an offset to the translation X axis based on the end effector frame\&. It is the diameter of a glass when you drink\&. 
.br
.PP
float \fIDrinkingHeight\fP This value is used only when the drinking mode is active\&. This add a an offset to the translation Y value\&. It is the height of a glass when you drink\&. 
.br
.PP
float \fIDrinkingLenght\fP This value is used only when the drinking mode is active\&. This add a an offset to the translation Z axis based on the end effector frame\&. It is the distance between the end effector and the glass when you drink\&. 
.br
.PP
int \fIEnableFlashErrorLog\fP Not used for now\&. 
.br
.PP
int \fIEnableFlashPositionLog\fP Not used for now\&. 
.br
.PP
int \fIExpansion[198]\fP Not used for now\&. 
.br
.PP
int \fIFingers2and3Inverted\fP This is a flag to invert finger 2 and 3\&. It is mostly used in rehab for left handed robot\&.(0 = normal, 1 = inverted) 
.br
.PP
\fBArmLaterality\fP \fILaterality\fP That tells you if the robot is left handed or right handed\&. If you modify this parameter, the change will take effect on the next REBOOT\&. 
.br
.PP
float \fIMaxForce\fP Not used for now\&. 
.br
.PP
float \fIMaxOrientationAcceleration\fP This is the max orientation acceleration of the robot's end effector\&. 
.br
.PP
float \fIMaxOrientationVelocity\fP This is the max orientation(ThetaX, ThetaY and ThetaZ) velocity of the robot's end effector\&. 
.br
.PP
float \fIMaxTranslationAcceleration\fP This is the max translation acceleration of the robot's end effector\&. 
.br
.PP
float \fIMaxTranslationVelocity\fP This is the max translation(X, Y and Z) velocity of the robot's end effector\&. 
.br
.PP
char \fIModel[\fBSTRING_LENGTH\fP]\fP This is where you can store the model number of the robot\&. The string must ends with a EndOfString character(\\0)\&. 
.br
.PP
char \fIOrganization[\fBSTRING_LENGTH\fP]\fP This is the name of the organization\&. The string must ends with a EndOfString character(\\0)\&. 
.br
.PP
float \fIRetractedPositionAngle\fP This value is the angle between the second carbon link(between actuator 2 and 3) and the X-Y plane\&. 
.br
.PP
int \fIRetractedPositionCount\fP This tells you how many positions there is in the advance retract trajectory\&. 
.br
.PP
\fBUserPosition\fP \fIRetractPositions[\fBNB_ADVANCE_RETRACT_POSITION\fP]\fP 
.br
.PP
float \fISensibility\fP This is the sensibility of the controller\&. The value is a % of the command received by the controller\&. Higher is the value and higher is the sensibility\&. Higher is the sensibility, quicker the end effector will reach the desired velocity for the same joystick command\&. 
.br
.PP
char \fISerial[\fBSTRING_LENGTH\fP]\fP This is where you can store the serial number of the robot\&. The string must ends with a EndOfString character(\\0)\&. 
.br
.PP
.RE
.PP
.SH "struct ControlMapping"
.PP 
This represents a group of functionalities mapped to some events triggered by a specific controller\&. 

As an example, the kinova 3-axis joystick has its own control mapping\&. This API also has its own control mapping\&. Note that since list A and list B cannot be used at the same time in the same control mapping, it implies that either one of the variable can have a >= 0 value\&. 
.PP
\fBClass Members:\fP
.RS 4
int \fIActualModeA\fP This is the actual index of the active mode map in the list A\&. If the list A is currently unused, this value will be -1\&. 
.br
.PP
int \fIActualModeB\fP is the actual index of the active mode map in the list B\&. If the list B is currently unused, this value will be -1\&. 
.br
.PP
\fBControlMappingMode\fP \fIMode\fP That indicates what kind of controller is in use\&. 
.br
.PP
\fBControlsModeMap\fP \fIModeControlsA[\fBMODE_MAP_COUNT\fP]\fP This is the mode map list A\&. By default, on the 3-axis kinova joystick, it corresponds to the modes accessible with the left button on the top of the stick\&. 
.br
.PP
\fBControlsModeMap\fP \fIModeControlsB[\fBMODE_MAP_COUNT\fP]\fP This is the mode map list B\&. By default, on the 3-axis kinova joystick, it corresponds to the modes accessible with the right button on the top of the stick\&. 
.br
.PP
int \fINumOfModesA\fP List A's element count\&. If this value exceeds MODE_MAP_COUNT, we got a problem\&. 
.br
.PP
int \fINumOfModesB\fP List B's element count\&. If this value exceeds MODE_MAP_COUNT, we got a problem\&. 
.br
.PP
.RE
.PP
.SH "struct ControlMappingCharts"
.PP 
This structure holds all the control mapping of the system\&. It is the entry point if you want to use the mapping system\&. 
.PP
\fBClass Members:\fP
.RS 4
int \fIActualControlMapping\fP This is the active control mapping\&. 
.br
.PP
\fBControlMapping\fP \fIMapping[\fBCONTROL_MAPPING_COUNT\fP]\fP This is the list of all control mapping stored in the charts\&. 
.br
.PP
int \fINumOfConfiguredMapping\fP This tells you how many control mapping we got in the charts\&. it cannot exceeds CONTROL_MAPPING_COUNT\&. 
.br
.PP
.RE
.PP
.SH "struct ControlsModeMap"
.PP 
Represents one mode map of a control mapping\&. Each control mapping has 2 list of mode map\&. 
.PP
\fBClass Members:\fP
.RS 4
\fBButtonEvents\fP \fIControlButtons[\fBBUTTON_EVENT_COUNT\fP]\fP All events from the buttons of the controller\&. 
.br
.PP
\fBStickEvents\fP \fIControlSticks[\fBSTICK_EVENT_COUNT\fP]\fP All events from the stick of the controller\&. 
.br
.PP
int \fIDiagonalsLocked\fP A flag that indicates if we can perform movement in more than one direction at a time\&. 
.br
.PP
int \fIExpansion\fP Not use for now\&. 
.br
.PP
.RE
.PP
.SH "struct Finger"
.PP 
Structure that represents a finger from the end effector's tool\&. 
.PP
\fBClass Members:\fP
.RS 4
float \fIActualAcceleration\fP Actual acceleration of the finger\&. 
.br
.PP
float \fIActualAverageCurrent\fP Not used for now\&. 
.br
.PP
float \fIActualCommand\fP Actual command of the finger\&. 
.br
.PP
float \fIActualCurrent\fP Actual current of the finger\&. 
.br
.PP
float \fIActualForce\fP Actual force of the finger\&. 
.br
.PP
float \fIActualPosition\fP Actual position of the finger\&. 
.br
.PP
float \fIActualSpeed\fP Actual velocity of the finger\&. 
.br
.PP
float \fIActualTemperature\fP Actual temperature of the finger\&. 
.br
.PP
unsigned int \fICodeVersion\fP Code version of the finger's firmware\&. 
.br
.PP
int \fICommunicationErrors\fP Not used for now\&. 
.br
.PP
float \fICycleCount\fP Not used for now\&. 
.br
.PP
unsigned int \fIDeviceID\fP Not used for now\&. 
.br
.PP
unsigned short \fIFingerAddress\fP Address of the finger\&. 
.br
.PP
char \fIID[\fBSTRING_LENGTH\fP]\fP ID of the finger\&. 
.br
.PP
unsigned short \fIIndex\fP Index of the finger\&. 
.br
.PP
unsigned short \fIIsFingerConnected\fP A flag that indicates if the finger is connected\&. 
.br
.PP
unsigned short \fIIsFingerInit\fP A flag that indicates if the finger is initialized or not\&. 
.br
.PP
float \fIMaxAcceleration\fP This is the max acceleration of the finger\&. 
.br
.PP
float \fIMaxAngle\fP This is the max position of the finger\&. 
.br
.PP
float \fIMaxCurrent\fP This is the max current of the finger\&. 
.br
.PP
float \fIMaxForce\fP This is the max force of the finger\&. 
.br
.PP
float \fIMaxSpeed\fP This is the max velocity of the finger\&. 
.br
.PP
float \fIMinAngle\fP This is the min position of the finger\&. 
.br
.PP
int \fIOscillatorTuningValue\fP Not used for now\&. 
.br
.PP
float \fIPeakCurrent\fP Not used for now\&. 
.br
.PP
float \fIPeakMaxTemp\fP Not used for now\&. 
.br
.PP
float \fIPeakMinTemp\fP Not used for now\&. 
.br
.PP
float \fIRunTime\fP Not used for now\&. 
.br
.PP
.RE
.PP
.SH "struct ForcesInfo"
.PP 
This structure contains informations about the torque and the force of the robotical arm\&. 
.PP
\fBClass Members:\fP
.RS 4
float \fIActuator1\fP That contains the torque of the actuator 1\&. 
.br
.PP
float \fIActuator2\fP That contains the torque of the actuator 2\&. 
.br
.PP
float \fIActuator3\fP That contains the torque of the actuator 3\&. 
.br
.PP
float \fIActuator4\fP That contains the torque of the actuator 4\&. 
.br
.PP
float \fIActuator5\fP That contains the torque of the actuator 5\&. 
.br
.PP
float \fIActuator6\fP That contains the torque of the actuator 6\&. 
.br
.PP
float \fIThetaX\fP That contains the force applied by the robotical arm around the X axis\&. 
.br
.PP
float \fIThetaY\fP That contains the force applied by the robotical arm around the Y axis\&. 
.br
.PP
float \fIThetaZ\fP That contains the force applied by the robotical arm around the Z axis\&. 
.br
.PP
float \fIX\fP That contains the force applied by the robotical arm on the X axis\&. 
.br
.PP
float \fIY\fP That contains the force applied by the robotical arm on the Y axis\&. 
.br
.PP
float \fIZ\fP That contains the force applied by the robotical arm on the Z axis\&. 
.br
.PP
.RE
.PP
.SH "struct GeneralInformations"
.PP 
This is structure hold almost all information of the robotical arm\&. 
.PP
\fBClass Members:\fP
.RS 4
float \fIAccelerationX\fP Acceleration X sensor's value\&. Unit is G\&. 
.br
.PP
float \fIAccelerationY\fP Acceleration Y sensor's value\&. Unit is G\&. 
.br
.PP
float \fIAccelerationZ\fP Acceleration Z sensor's value\&. Unit is G\&. 
.br
.PP
\fBJoystickCommand\fP \fIActualJoystickCommand\fP Actual joystick command received by the robotical arm\&. 
.br
.PP
\fBZoneLimitation\fP \fIActualLimitations\fP Actua limitation applied on the robotical arm\&. 
.br
.PP
\fBSystemStatus\fP \fIActualSystemStatus\fP System status\&. 
.br
.PP
int \fIActuatorsCommErrors[6]\fP An array that contains communication errors of all actuators\&. 
.br
.PP
float \fIActuatorsTemperatures[6]\fP An array of all the connected peripheral\&. 
.br
.PP
float \fIAveragePower\fP Average power consumed on the main supply\&. Unit is W\&. 
.br
.PP
unsigned int \fICodeRevision\fP Firmware's code revision\&. 
.br
.PP
unsigned int \fICodeVersion\fP Firmware's code version\&. (Version\&.Major\&.Minor) 
.br
.PP
\fBUserPosition\fP \fICommand\fP The actual angular and cartesian command information\&. 
.br
.PP
unsigned short \fIConnectedActuatorCount\fP Connected actuator count\&. 
.br
.PP
float \fIControlIncrement[6]\fP Actual control increment from the actuators\&. 
.br
.PP
unsigned short \fIController\fP The active controller\&. Example : 3-axis joystick, API, universal interface, \&.\&.\&. 
.br
.PP
unsigned short \fIControlMode\fP Not used for now\&. 
.br
.PP
double \fIControlTimeAbsolute\fP Not used for now\&. 
.br
.PP
double \fIControlTimeFromStartup\fP Control time since the last boot\&. The control time all the time the the robotical arm receive commands from any controller\&. 
.br
.PP
\fBUserPosition\fP \fICurrent\fP The actual angular and cartesian current information\&. 
.br
.PP
unsigned short \fIErrorsExternalCANCount\fP Communication error from the main external communication bus\&. 
.br
.PP
unsigned short \fIErrorsExternalSPICount\fP Communication error from the external SPI\&. 
.br
.PP
unsigned short \fIErrorsMainCANCount\fP Communication error from the main internal communication bus\&. 
.br
.PP
unsigned short \fIErrorsMainSPICount\fP Communication error from the main SPI\&. 
.br
.PP
unsigned short \fIErrorsSpiExpansion1\fP Not in used now\&. 
.br
.PP
unsigned short \fIErrorsSpiExpansion2\fP Not in used now\&. 
.br
.PP
float \fIExpansionFloat\fP Not used for now\&. 
.br
.PP
int \fIExpansionLong1\fP not used for now\&. 
.br
.PP
int \fIExpansionLong2\fP Not used for now\&. 
.br
.PP
unsigned char \fIExpansionsBytes[192]\fP Not used for now 
.br
.PP
float \fIFingerControlIncrement[3]\fP Actual control increment from the fingers\&. 
.br
.PP
int \fIFingersCommErrors[3]\fP An array that contains communication errors of all fingers\&. 
.br
.PP
float \fIFingersTemperatures[3]\fP An array that contains the fingers's temperature\&. 
.br
.PP
\fBUserPosition\fP \fIForce\fP The actual angular and cartesian force information\&. 
.br
.PP
float \fIFutureTemperatures[3]\fP Not used for now\&. 
.br
.PP
unsigned short \fIHandMode\fP Not used for now\&. 
.br
.PP
unsigned int \fIIndexStartup\fP Not used for now\&. 
.br
.PP
unsigned int \fIPeripheralsConnected[4]\fP An array of all the connected peripheral\&. 
.br
.PP
unsigned int \fIPeripheralsDeviceID[4]\fP An array of all the connected peripheral's ID\&. 
.br
.PP
\fBUserPosition\fP \fIPosition\fP The actual angular and cartesian position information\&. 
.br
.PP
unsigned short \fIPositionType\fP Type of the actual position\&. 
.br
.PP
float \fIPower\fP Power consumed on the main supply\&. Unit is W\&. 
.br
.PP
float \fISensorExpansion1\fP Not used for now\&. 
.br
.PP
float \fISensorExpansion2\fP Not used for now\&. 
.br
.PP
float \fISensorExpansion3\fP Not used for now\&. 
.br
.PP
unsigned short \fIStatus\fP Not used for now\&. 
.br
.PP
float \fISupplyVoltage\fP Main supply voltage\&.(24 V) Unit is V\&. 
.br
.PP
double \fITimeAbsolute\fP not used for now 
.br
.PP
double \fITimeFromStartup\fP Time in second since the last boot\&. 
.br
.PP
float \fITimeStampSavings\fP Not used for now\&. 
.br
.PP
float \fITotalCurrent\fP Current consumed on the main supply\&. Unit is A\&. 
.br
.PP
.RE
.PP
.SH "struct Gripper"
.PP 
Structure that represents the robotical arm's gripper\&. 
.PP
\fBClass Members:\fP
.RS 4
\fBFinger\fP \fIFingers[\fBJACO_FINGERS_COUNT\fP]\fP The 3 fingers of the gripper\&. 
.br
.PP
char \fIModel[\fBSTRING_LENGTH\fP]\fP Model of the gripper\&. 
.br
.PP
.RE
.PP
.SH "struct PeripheralInfo"
.PP 
This data structure holds information that describes an abstract peripheral\&. 
.PP
\fBClass Members:\fP
.RS 4
unsigned int \fIAddress\fP Address of the peripheral\&. 
.br
.PP
unsigned int \fICodeVersion\fP The code's version of the peripheral\&. 
.br
.PP
unsigned int \fIHandle\fP Handle to the peripheral\&. Internal use only\&. 
.br
.PP
unsigned int \fIPort\fP Port's type of the peripheral\&. 
.br
.PP
unsigned int \fIType\fP Type of peripheral\&. 
.br
.PP
.RE
.PP
.SH "struct QuickStatus"
.PP 
This structure holds various informations but mostly it is flag status\&. 
.PP
\fBClass Members:\fP
.RS 4
unsigned char \fICartesianFaultState\fP This is a flag that indicates the actual control frame\&. (0 = fixed - 1 = rotating frame) 
.br
.PP
unsigned char \fIControlActiveModule\fP This flag indicates the active control module\&. This value is directly associated with the enum CONTROL_MODULE\&. 
.br
.PP
unsigned char \fIControlEnableStatus\fP This is a flag that indicates if the control is on\&. (0 = ON - 1 = OFF) 
.br
.PP
unsigned char \fIControlFrameType\fP This is a flag that indicates the actual control frame\&. (0 = fixed - 1 = rotating frame) 
.br
.PP
unsigned char \fICurrentLimitationStatus\fP This is a flag that indicates if the current limitation is on\&. (0 = ON - 1 = OFF) 
.br
.PP
unsigned char \fIFinger1Status\fP This flag's value is 1 if the finger #1 is initialized\&. 
.br
.PP
unsigned char \fIFinger2Status\fP This flag's value is 1 if the finger #1 is initialized\&. 
.br
.PP
unsigned char \fIFinger3Status\fP This flag's value is 1 if the finger #1 is initialized\&. 
.br
.PP
unsigned char \fIForceControlStatus\fP This is a flag that indicates if the force control is ON\&. (0 = ON - 1 = OFF) 
.br
.PP
unsigned char \fIRetractComplexity\fP This is a flag that indicates if the advance retract is on\&. (0 = basic retract - 1 = advance retract) 
.br
.PP
unsigned char \fIRetractType\fP This is the retract state\&. this value is directly associated with the enum RETRACT_TYPE\&. 
.br
.PP
unsigned char \fIRobotEdition\fP Not used for now\&. 
.br
.PP
unsigned char \fIRobotType\fP This tells you if the robotical arm is a JACO or a MICO((0 = JACO - 1 = MICO)) 
.br
.PP
unsigned char \fITorqueSensorsStatus\fP That tells if torque sensors are available or not\&. 
.br
.PP
.RE
.PP
.SH "struct SingularityVector"
.PP 
This data structure represents the informations regarding the singularities surrounding the end effector\&. It is not used for now but will be in the future\&. 
.PP
\fBClass Members:\fP
.RS 4
int \fIOrientationSingularityCount\fP 
.br
.PP
float \fIOrientationSingularityDistance\fP 
.br
.PP
\fBCartesianInfo\fP \fIRepulsionVector\fP 
.br
.PP
int \fITranslationSingularityCount\fP 
.br
.PP
float \fITranslationSingularityDistance\fP 
.br
.PP
.RE
.PP
.SH "struct StickEvents"
.PP 
This is an event from a controller's stick\&. Each variable of the struct can be mapped with a ControlFunctionalityTypeEnum\&. 
.PP
\fBClass Members:\fP
.RS 4
unsigned char \fIMinus\fP This represents the negative value of the event\&. As an example, if you incline the stick to the left it will trigger that event\&. 
.br
.PP
unsigned char \fIPlus\fP This represents the positive value of the event\&. As an example, if you incline the stick to the right it will trigger that event\&. 
.br
.PP
.RE
.PP
.SH "struct SystemError"
.PP 
This represents a system error\&. Every error generated by the system is logged in the robot's flash memory\&. 
.PP
\fBClass Members:\fP
.RS 4
unsigned int \fIData[\fBERROR_DATA_COUNT_MAX\fP]\fP internal use only\&. 
.br
.PP
int \fIDataCount\fP internal use only\&. 
.br
.PP
unsigned int \fIErrorHeader\fP Error's header\&. Not used for now\&. 
.br
.PP
\fBerrorLoggerType\fP \fIErrorType\fP The error's type\&. 
.br
.PP
int \fIFirmwareVersion\fP The firmware's code version\&. 
.br
.PP
int \fIKeosVersion\fP The Keos's code version\&. Keos is a software layer that contains low level stuff\&. 
.br
.PP
bool \fILayerErrorStatus[\fBERROR_LAYER_COUNT\fP]\fP Internal use only\&. 
.br
.PP
int \fILifeTime\fP Internal use only\&. 
.br
.PP
unsigned int \fISystemTime\fP Not used for now\&. 
.br
.PP
.RE
.PP
.SH "struct SystemStatus"
.PP 
This structure holds system status flags\&. 
.PP
\fBClass Members:\fP
.RS 4
unsigned int \fIArmLaterality\fP That tells if the robotical arm is right handed or left handed\&. (0 = RIGHTHANDED - 1 = LEFTHANDED) 
.br
.PP
unsigned int \fIDrinkingMode\fP That tells if the drinking mode is active\&. (0 = active - 1 = not active) 
.br
.PP
unsigned int \fIFingersActive\fP A flag that indicates if the translation mode is currently active\&.(Based on the actual mapping)\&. 
.br
.PP
unsigned int \fIJoystickActive\fP That tells if the joystick is active\&. (0 = active - 1 = not active) 
.br
.PP
unsigned int \fIMajorErrorOccured\fP A flag that indicates that a major error has occured\&. 
.br
.PP
unsigned int \fIRetractStatus\fP That tells if the joystick is active\&. (0 = active - 1 = not active) 
.br
.PP
unsigned int \fIRotationActive\fP A flag that indicates if the orientation mode is currently active\&.(Based on the actual mapping)\&. 
.br
.PP
unsigned int \fITranslationActive\fP A flag that indicates if the translation mode is currently active\&.(Based on the actual mapping)\&. 
.br
.PP
unsigned int \fIWarningLowVoltage\fP A warning flag that indicates a low voltage on the robotical arm\&. 
.br
.PP
unsigned int \fIWarningOverchargeFingers\fP A warning flag that indicates an overcharge on the fingers of the robotical arm\&. 
.br
.PP
unsigned int \fIWarningOverchargeForce\fP A warning flag that indicates a general overcharge on the robotical arm\&. 
.br
.PP
.RE
.PP
.SH "struct TrajectoryFIFO"
.PP 
This data structure represents the informations regarding the robot's trajectory's FIFO\&. 
.PP
\fBClass Members:\fP
.RS 4
unsigned int \fIMaxSize\fP This is the size of the trajectory FIFO\&. 
.br
.PP
unsigned int \fITrajectoryCount\fP This tells you how many trajectory point are still stored in the robot\&. 
.br
.PP
float \fIUsedPercentage\fP This is the usage of the trajectory FIFO\&. 
.br
.PP
.RE
.PP
.SH "struct Zone"
.PP 
that represents a protection zone\&. 
.PP
\fBClass Members:\fP
.RS 4
int \fIExpansion1\fP Not used for now\&. 
.br
.PP
int \fIExpansion2\fP Not used for now\&. 
.br
.PP
int \fIID\fP ID of the zone\&. 
.br
.PP
\fBZoneLimitation\fP \fIzoneLimitation\fP \fBLimitation\fP to apply inside the protection zone\&. As an example, if you want the zone to be am unaccessible zone, you need to limit the velocity to 0\&. 
.br
.PP
\fBZoneShape\fP \fIzoneShape\fP Geometric shape of the protection zone\&. 
.br
.PP
.RE
.PP
.SH "struct ZoneLimitation"
.PP 
This represents a group of limitations that can be applied to a trajectory point\&. 
.PP
\fBClass Members:\fP
.RS 4
float \fIaccelerationParameter1\fP Not used for now\&. 
.br
.PP
float \fIaccelerationParameter2\fP Not used for now\&. 
.br
.PP
float \fIaccelerationParameter3\fP Not used for now\&. 
.br
.PP
float \fIforceParameter1\fP Not used for now\&. 
.br
.PP
float \fIforceParameter2\fP Not used for now\&. 
.br
.PP
float \fIforceParameter3\fP Not used for now\&. 
.br
.PP
float \fIspeedParameter1\fP The first speed parameter\&. Used in angular control, it is the velocity of the actuator 1, 2 and 3 and if used in cartesian control, it is the translation velocity\&. 
.br
.PP
float \fIspeedParameter2\fP The second speed parameter\&. Used in angular control, it is the velocity of the actuator 4, 5 and 6 and if used in cartesian control, it is the orientation velocity\&. 
.br
.PP
float \fIspeedParameter3\fP Not used for now\&. 
.br
.PP
.RE
.PP
.SH "struct ZoneList"
.PP 
This structure represents the complete list of protection zone of the robotical arm\&. 
.PP
\fBClass Members:\fP
.RS 4
int \fIExpansion1\fP Not used for now\&. 
.br
.PP
int \fINbZones\fP This is the active zone count\&. 
.br
.PP
\fBZone\fP \fIZones[\fBLEGACY_CONFIG_NB_ZONES_MAX\fP]\fP This is the list of zone itself\&. 
.br
.PP
.RE
.PP
.SH "struct ZoneShape"
.PP 
Represents the 3D shape of a protection zone\&. 
.PP
\fBClass Members:\fP
.RS 4
int \fIExpansion1\fP Not used for now\&. 
.br
.PP
\fBCartesianInfo\fP \fIPoints[\fBLEGACY_CONFIG_NB_POINTS_COUNT\fP]\fP The points that describe the shape\&. 
.br
.PP
\fBShapeType\fP \fIshapeType\fP This is the geometric type of shape\&. 
.br
.PP
.RE
.PP
.SH "Macro Definition Documentation"
.PP 
.SS "#define BUTTON_EVENT_COUNT   26"

.PP
This is the size of the array ControlButtons contained in the structure \fBControlsModeMap\fP \&. 
.SS "#define CONTROL_MAPPING_COUNT   6"

.PP
This is the size of the array Mapping contained in the structure \fBControlMappingCharts\fP \&. 
.SS "#define ERROR_DATA_COUNT_MAX   50"

.PP
This is the size of the data array stored in a \fBSystemError\fP object\&. 
.SS "#define ERROR_FILEREADING   5003"

.PP
This is an error code\&. It means that the function has some problem reading a file\&. Most of the time it is because the user don't have the privileges to do it\&. 
.SS "#define ERROR_LAYER_COUNT   7"

.PP
The robot's firmware has several software layers\&. This describes how many layer there is in the firmware\&. 
.SS "#define ERROR_MEMORY   5002"

.PP
This is an error code\&. It means that there was a memory related error\&. Most of the time it is because the system does not have enough memory\&. 
.SS "#define ERROR_UNKNOWFILE   5001"

.PP
This is an error code\&. It means that the file you are trying to interact with does not exist or is corrupted\&. Either way, the OS does not recognise it\&. 
.SS "#define JACO_FINGERS_COUNT   3"

.PP
This is the max finger count in a robot\&. (Jaco has 3 fingers and Mico has 2 fingers) 
.SS "#define JOYSTICK_BUTTON_COUNT   16"

.PP
Size of the \fBControlsModeMap\fP array in the structure \fBJoystickCommand\fP\&. 
.SS "#define LEGACY_CONFIG_NB_POINTS_COUNT   8"

.PP
This is the size of the array Points in a \fBZoneShape\fP \&. 
.SS "#define LEGACY_CONFIG_NB_ZONES_MAX   10"

.PP
This represents the max count of protection zones that can be stored in the robot's memory\&. 
.SS "#define MODE_MAP_COUNT   6"

.PP
This is the size of the arrays ModeControlsA and ModeControlsB contained in the structure \fBControlMapping\fP \&. 
.SS "#define NB_ADVANCE_RETRACT_POSITION   20"

.PP
Max size of the advance retract trajectory that is stored in the \fBClientConfigurations\fP\&. 
.SS "#define STICK_EVENT_COUNT   6"

.PP
This is the size of the array ControlSticks contained in the structure \fBControlsModeMap\fP \&. 
.SS "#define STRING_LENGTH   20"

.PP
This is the size of all strings stored in the robot's firmware\&. 
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBArmLaterality\fP"

.PP
That indicates if the robot will be left handed or right handed\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIRIGHTHAND \fP\fP
Right handed 
.TP
\fB\fILEFTHAND \fP\fP
Left handed 
.PP
.nf
158 {
159     RIGHTHAND, 
160     LEFTHAND,  
161 };
.fi
.SS "enum \fBCONTROL_MODULE\fP"

.PP
That describes a control module of the robotical arm's firmware\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fICONTROL_MODULE_NONE \fP\fP
No control module selected\&. The robotical arm cannot moves\&. 
.TP
\fB\fICONTROL_MODULE_ANGULAR_VELOCITY \fP\fP
Angular velocity control mode\&. Values sent to the actuators are velocity\&. Unit: degree / second\&. 
.TP
\fB\fICONTROL_MODULE_ANGULAR_POSITION \fP\fP
Angular position control mode\&. Values sent to the actuators are position\&. Unit: degree\&. 
.TP
\fB\fICONTROL_MODULE_CARTESIAN_VELOCITY \fP\fP
Cartesian velocity control mode\&. values sent to the end effector are velocity\&. translation Unit: meter / second, orientation unit: RAD / second\&. 
.TP
\fB\fICONTROL_MODULE_CARTESIAN_POSITION \fP\fP
Cartesian position control mode\&. values sent to the actuators are velocity\&. translation Unit: meter, orientation unit: RAD\&. 
.TP
\fB\fICONTROL_MODULE_RETRACT \fP\fP
Retract control mode\&. This manage movement between the READY(HOME) and the RETRACTED position\&. This can be angular or cartesian position control\&. 
.TP
\fB\fICONTROL_MODULE_TRAJECTORY \fP\fP
Not used for now\&. 
.TP
\fB\fICONTROL_MODULE_PREDEFINED \fP\fP
This manages the pre programmed position(GOTO)\&. This is position control\&. 
.TP
\fB\fICONTROL_MODULE_TIMEDELAY \fP\fP
This manages the time delay during a trajectory\&. 
.PP
.nf
193 {
197     CONTROL_MODULE_NONE,
198 
202     CONTROL_MODULE_ANGULAR_VELOCITY,
203 
207     CONTROL_MODULE_ANGULAR_POSITION,
208 
213     CONTROL_MODULE_CARTESIAN_VELOCITY,
214 
219     CONTROL_MODULE_CARTESIAN_POSITION,
220 
225     CONTROL_MODULE_RETRACT,
226 
230     CONTROL_MODULE_TRAJECTORY,
231 
235     CONTROL_MODULE_PREDEFINED,
236 
240     CONTROL_MODULE_TIMEDELAY,
241 };
.fi
.SS "enum \fBCONTROL_TYPE\fP"

.PP
This represents a type of control\&. For now, there is 2 type of control, it can either cartesian control or angular control\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fICONTROL_TYPE_CARTESIAN \fP\fP
Cartesian control\&. (translation and orientation) 
.TP
\fB\fICONTROL_TYPE_ANGULAR \fP\fP
Angular control\&. (joint by joint) 
.PP
.nf
184 {
185     CONTROL_TYPE_CARTESIAN = 0, 
186     CONTROL_TYPE_ANGULAR = 1    
187 };
.fi
.SS "enum \fBControlFunctionalityTypeEnum\fP"

.PP
This is the list of available feature that can be mapped with a controller through the mappign system\&. Every list of mode that a mapping contains is mapped with one of these features\&. The default value is CF_NoFunctionality\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fICF_NoFunctionality \fP\fP
Default value, represents nothing\&. 
.TP
\fB\fICF_Disable_EnableJoystick \fP\fP
Virtually turn on and off the joystick\&. 
.TP
\fB\fICF_Retract_ReadyToUse \fP\fP
Home the robot if the is initialized and anywhere in the workspace except between the READY and RETRACTED position\&. Go to RETRACTED position if the robot is in READY position and go to READY position if the robot is in RETRACTED position\&. is in READY mode\&. 
.TP
\fB\fICF_Change_TwoAxis_ThreeAxis \fP\fP
Not used for now\&. 
.TP
\fB\fICF_Change_DrinkingMode \fP\fP
Put the robotical arm in the drinking mode\&. 
.TP
\fB\fICF_Cycle_ModeA_list \fP\fP
Iterate mode in the list A\&. 
.TP
\fB\fICF_Cycle_ModeB_list \fP\fP
Iterate mode in the list B\&. 
.TP
\fB\fICF_DecreaseSpeed \fP\fP
Divide the velocity by 2\&. 
.TP
\fB\fICF_IncreaseSpeed \fP\fP
Double the speed\&. 
.TP
\fB\fICF_Goto_Position1 \fP\fP
Move the robotical arm's end position to the GOTO position 1\&. 
.TP
\fB\fICF_Goto_Position2 \fP\fP
Move the robotical arm's end position to the GOTO position 2\&. 
.TP
\fB\fICF_Goto_Position3 \fP\fP
Move the robotical arm's end position to the GOTO position 3\&. 
.TP
\fB\fICF_Goto_Position4 \fP\fP
Move the robotical arm's end position to the GOTO position 4\&. 
.TP
\fB\fICF_Goto_Position5 \fP\fP
Move the robotical arm's end position to the GOTO position 5\&. 
.TP
\fB\fICF_RecordPosition1 \fP\fP
Store the current cartesian position into the GOTO position 1\&. 
.TP
\fB\fICF_RecordPosition2 \fP\fP
Store the current cartesian position into the GOTO position 2\&. 
.TP
\fB\fICF_RecordPosition3 \fP\fP
Store the current cartesian position into the GOTO position 3\&. 
.TP
\fB\fICF_RecordPosition4 \fP\fP
Store the current cartesian position into the GOTO position 4\&. 
.TP
\fB\fICF_RecordPosition5 \fP\fP
Store the current cartesian position into the GOTO position 5\&. 
.TP
\fB\fICF_X_Positive \fP\fP
Move the robotical arm's end effector along the X axis toward the positive values\&. If the robotical arm is in angular control, this will move the actuator 1 counterclockwise\&. 
.TP
\fB\fICF_X_Negative \fP\fP
Move the robotical arm's end effector along the X axis toward the negative values\&. If the robotical arm is in angular control, this will move the actuator 1 clockwise\&. 
.TP
\fB\fICF_Y_Positive \fP\fP
Move the robotical arm's end effector along the Y axis toward the positive values\&. If the robotical arm is in angular control, this will move the actuator 2 counterclockwise\&. 
.TP
\fB\fICF_Y_Negative \fP\fP
Move the robotical arm's end effector along the Y axis toward the negative values\&. If the robotical arm is in angular control, this will move the actuator 2 clockwise\&. 
.TP
\fB\fICF_Z_Positive \fP\fP
Move the robotical arm's end effector along the Z axis toward the positive values\&. If the robotical arm is in angular control, this will move the actuator 3 counterclockwise\&. 
.TP
\fB\fICF_Z_Negative \fP\fP
Move the robotical arm's end effector along the Z axis toward the negative values\&. If the robotical arm is in angular control, this will move the actuator 3 clockwise\&. 
.TP
\fB\fICF_R_Positive \fP\fP
Rotate the robotical arm's end effector around the X axis counterclockwise\&. If the robotical arm is in angular control, this will move the actuator 4 counterclockwise\&. 
.TP
\fB\fICF_R_Negative \fP\fP
Rotate the robotical arm's end effector around the X axis clockwise\&. If the robotical arm is in angular control, this will move the actuator 4 clockwise\&. 
.TP
\fB\fICF_U_Positive \fP\fP
Rotate the robotical arm's end effector around the Y axis counterclockwise\&. If the robotical arm is in angular control, this will move the actuator 5 counterclockwise\&. 
.TP
\fB\fICF_U_Negative \fP\fP
Rotate the robotical arm's end effector around the X axis clockwise\&. If the robotical arm is in angular control, this will move the actuator 5 clockwise\&. 
.TP
\fB\fICF_V_Positive \fP\fP
Rotate the robotical arm's end effector around the Z axis counterclockwise\&. If the robotical arm is in angular control, this will move the actuator 6 counterclockwise\&. 
.TP
\fB\fICF_V_Negative \fP\fP
Rotate the robotical arm's end effector around the Z axis clockwise\&. If the robotical arm is in angular control, this will move the actuator 6 clockwise\&. 
.TP
\fB\fICF_OpenHandOneFingers \fP\fP
Not used for now\&. 
.TP
\fB\fICF_CloseHandOneFingers \fP\fP
Not used for now\&. 
.TP
\fB\fICF_OpenHandTwoFingers \fP\fP
Open fingers 1 and 2 of the hand\&. 
.TP
\fB\fICF_CloseHandTwoFingers \fP\fP
Close fingers 1 and 2 of the hand\&. 
.TP
\fB\fICF_OpenHandThreeFingers \fP\fP
Open fingers 1, 2 and 3 of the hand\&. 
.TP
\fB\fICF_CloseHandThreeFingers \fP\fP
Close fingers 1, 2 and 3 of the hand\&. 
.TP
\fB\fICF_ForceAngularVelocity \fP\fP
Put the robotical arm in angular control mode\&. 
.TP
\fB\fICF_ForceControlStatus \fP\fP
Turn ON/OFF the force control if the feature is available\&. 
.TP
\fB\fICF_Trajectory \fP\fP
.TP
\fB\fICF_AutomaticOrientationXPlus \fP\fP
Orient the end effector toward the positive X Axis\&. 
.TP
\fB\fICF_AutomaticOrientationXMinus \fP\fP
Orient the end effector toward the negative X Axis\&. 
.TP
\fB\fICF_AutomaticOrientationYPlus \fP\fP
Orient the end effector toward the positive Y Axis\&. 
.TP
\fB\fICF_AutomaticOrientationYMinus \fP\fP
Orient the end effector toward the negative Y Axis\&. 
.TP
\fB\fICF_AutomaticOrientationZPlus \fP\fP
Orient the end effector toward the positive Z Axis\&. 
.TP
\fB\fICF_AutomaticOrientationZMinus \fP\fP
Orient the end effector toward the negative Z Axis\&. 
.TP
\fB\fICF_AdvanceGOTO_1 \fP\fP
Move the robot along the advance GOTO position 1\&. 
.TP
\fB\fICF_AdvanceGOTO_Clear_1 \fP\fP
Clear the advance GOTO's trajectory 1\&. 
.TP
\fB\fICF_AdvanceGOTO_Add_1 \fP\fP
Add a point to the advance GOTO's trajectory 1\&. 
.PP
.nf
938 {
942     CF_NoFunctionality = 0,
943 
947     CF_Disable_EnableJoystick = 1,
948 
955     CF_Retract_ReadyToUse = 2,
956 
960     CF_Change_TwoAxis_ThreeAxis = 3,
961 
965     CF_Change_DrinkingMode = 4,
966 
970     CF_Cycle_ModeA_list = 5,
971 
975     CF_Cycle_ModeB_list = 6,
976 
980     CF_DecreaseSpeed = 7,
981 
985     CF_IncreaseSpeed = 8,
986 
990     CF_Goto_Position1 = 9,
991 
995     CF_Goto_Position2 = 10,
996 
1000     CF_Goto_Position3 = 11,
1001 
1005     CF_Goto_Position4 = 12,
1006 
1010     CF_Goto_Position5 = 13,
1011 
1015     CF_RecordPosition1 = 14,
1016 
1020     CF_RecordPosition2 = 15,
1021 
1025     CF_RecordPosition3 = 16,
1026 
1030     CF_RecordPosition4 = 17,
1031 
1035     CF_RecordPosition5 = 18,
1036 
1041     CF_X_Positive = 19,
1042 
1047     CF_X_Negative = 20,
1048 
1053     CF_Y_Positive = 21,
1054 
1059     CF_Y_Negative = 22,
1060 
1065     CF_Z_Positive = 23,
1066 
1071     CF_Z_Negative = 24,
1072 
1077     CF_R_Positive = 25,
1078 
1083     CF_R_Negative = 26,
1084 
1089     CF_U_Positive = 27,
1090 
1095     CF_U_Negative = 28,
1096 
1101     CF_V_Positive = 29,
1102 
1107     CF_V_Negative = 30,
1108 
1112     CF_OpenHandOneFingers = 31,
1113 
1117     CF_CloseHandOneFingers = 32,
1118 
1122     CF_OpenHandTwoFingers = 33,
1123 
1127     CF_CloseHandTwoFingers = 34,
1128 
1132     CF_OpenHandThreeFingers = 35,
1133 
1137     CF_CloseHandThreeFingers = 36,
1138 
1142     CF_ForceAngularVelocity = 37,
1143 
1147     CF_ForceControlStatus = 38,
1148 
1149     CF_Trajectory = 39,
1150 
1154     CF_AutomaticOrientationXPlus = 40,
1155 
1159     CF_AutomaticOrientationXMinus = 41,
1160 
1164     CF_AutomaticOrientationYPlus = 42,
1165 
1169     CF_AutomaticOrientationYMinus = 43,
1170 
1174     CF_AutomaticOrientationZPlus = 44,
1175 
1179     CF_AutomaticOrientationZMinus = 45,
1180 
1184     CF_AdvanceGOTO_1 = 46,
1185 
1189     CF_AdvanceGOTO_Clear_1 = 47,
1190 
1194     CF_AdvanceGOTO_Add_1 = 48,
1195 };
.fi
.SS "enum \fBController\fP"

.PP
This represents a type of controller\&. A controller is an entity that can send control commands to the robot\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fITHREE_AXIS_JOYSTICK \fP\fP
A three axis joystick controller\&. 
.TP
\fB\fITWO_AXIS_JOYSTICK \fP\fP
A two axis joystick controller\&. 
.TP
\fB\fIAPI \fP\fP
The kinova API\&. 
.TP
\fB\fIEASY_RIDER \fP\fP
The easy rider controller\&. 
.TP
\fB\fIUNIVERSAL_INTERFACE \fP\fP
The kinova universal interface controller\&. 
.TP
\fB\fIEXTERNAL_CUSTOMINTERFACE \fP\fP
An external custom interface controller\&. 
.TP
\fB\fINONE \fP\fP
No interface\&. 
.TP
\fB\fIOLED_DISPLAY \fP\fP
An OLED display\&. 
.PP
.nf
168 {
169          THREE_AXIS_JOYSTICK = 0, 
170            TWO_AXIS_JOYSTICK = 1, 
171                          API = 2, 
172                   EASY_RIDER = 3, 
173          UNIVERSAL_INTERFACE = 4, 
174     EXTERNAL_CUSTOMINTERFACE = 5, 
175                         NONE = 6, 
176                 OLED_DISPLAY = 7  
177 };
.fi
.SS "enum \fBControlMappingMode\fP"

.PP
Indicates the type of controller\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIOneAxis \fP\fP
Represents a 1-axis controller\&. 
.TP
\fB\fITwoAxis \fP\fP
Represents a 2-axis controller\&. 
.TP
\fB\fIThreeAxis \fP\fP
Represents a 3-axis controller\&. 
.TP
\fB\fISixAxis \fP\fP
Represents a 6-axis controller\&. 
.PP
.nf
1260 {
1264     OneAxis,
1265 
1269     TwoAxis,
1270 
1274     ThreeAxis,
1275 
1279     SixAxis
1280 };
.fi
.SS "enum \fBerrorLoggerType\fP"

.PP
That represents the type of an error\&. It is used mostly for identification\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIERROR_NOTINITIALIZED \fP\fP
Default value\&. 
.TP
\fB\fIkeos_err1 \fP\fP
An error from the system's first software layer\&. It is very low level stuff\&. 
.TP
\fB\fIkeos_err2 \fP\fP
An error from the system's second software layer\&. It is very low level stuff\&. 
.TP
\fB\fIkeos_err3 \fP\fP
An error from the system's third software layer\&. It is low level stuff\&. 
.TP
\fB\fIUser_err_start_marker \fP\fP
Not used for now\&. 
.TP
\fB\fIerrorlog_Actuator_Temperature \fP\fP
Indicates that one of the actuator's temperature has been over the temperature limit\&. 
.TP
\fB\fIerrorlog_Actuator_TemperatureOK \fP\fP
Indicates that the actuator that was in temperature error but is now ok\&. 
.TP
\fB\fIerrorlog_Finger_Temperature \fP\fP
Indicates that one of the finger's temperature has been over the temperature limit\&. 
.TP
\fB\fIerrorlog_Finger_TemperatureOK \fP\fP
Indicates that one of the finger's temperature was over the temperature limit but is now ok\&. 
.TP
\fB\fIerrorlog_voltage \fP\fP
Indicates that the voltage is below the minimum value\&. 
.TP
\fB\fIerrorlog_voltageOK \fP\fP
Indicate that the voltage was in error but is now ok\&. 
.TP
\fB\fIerrorlog_current_FingersClosing \fP\fP
That indicates the one of the finger's current has been over the current limit while closing\&. 
.TP
\fB\fIerrorlog_current_FingersOpening \fP\fP
That indicates the one of the finger's current has been over the current limit while opening\&. 
.TP
\fB\fIerrorlog_current_FingersOK \fP\fP
That indicates the one of the finger's current was in error but is now ok\&. 
.TP
\fB\fIerrorlog_current_Actuators \fP\fP
That indicates the one of the actuators's current has been over the current limit\&. 
.TP
\fB\fIerrorlog_current_ActuatorsOK \fP\fP
That indicates the one of the actuators was in current error but is now ok\&. 
.TP
\fB\fIerrorLog_RobotStatus_Build_Incomplete \fP\fP
The system did not detect enough hardware to virtually build a JACO or a MICO\&. 
.TP
\fB\fIerrorLogger_END \fP\fP
Not used for now\&. 
.PP
.nf
1383 {
1387     ERROR_NOTINITIALIZED,
1388 
1392     keos_err1,
1393 
1397     keos_err2,
1398 
1402     keos_err3,
1403 
1407     User_err_start_marker,
1408 
1412     errorlog_Actuator_Temperature,
1413 
1417     errorlog_Actuator_TemperatureOK,
1418 
1422     errorlog_Finger_Temperature,
1423 
1427     errorlog_Finger_TemperatureOK,
1428 
1432     errorlog_voltage,
1433 
1437     errorlog_voltageOK,
1438 
1442     errorlog_current_FingersClosing,
1443 
1447     errorlog_current_FingersOpening,
1448 
1452     errorlog_current_FingersOK,
1453 
1457     errorlog_current_Actuators,
1458 
1462     errorlog_current_ActuatorsOK,
1463 
1467     errorLog_RobotStatus_Build_Incomplete,
1468 
1472     errorLogger_END
1473 };
.fi
.SS "enum \fBHAND_MODE\fP"

.PP
That indicates how the end effector will be used\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIHAND_NOMOVEMENT \fP\fP
Fingers will not move\&. 
.TP
\fB\fIPOSITION_MODE \fP\fP
Fingers will move using position control\&. 
.TP
\fB\fIVELOCITY_MODE \fP\fP
Fingers will move using velocity control\&. 
.PP
.nf
148 {
149     HAND_NOMOVEMENT, 
150     POSITION_MODE,   
151     VELOCITY_MODE,   
152 };
.fi
.SS "enum \fBPERIPHERAL_TYPE\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIPERIPHERAL_TYPE_NONE \fP\fP
Unknown type\&. 
.TP
\fB\fIPERIPHERAL_TYPE_ANY \fP\fP
Abstract peripheral\&. internal use only\&. 
.TP
\fB\fIPERIPHERAL_TYPE_ACTUATORK01 \fP\fP
A joint's actuator\&. 
.TP
\fB\fIPERIPHERAL_TYPE_FINGERK01 \fP\fP
A finger\&. 
.TP
\fB\fIPERIPHERAL_TYPE_JOYSTICK \fP\fP
A joystick\&. 
.TP
\fB\fIPERIPHERAL_TYPE_VIRTUAL_JOYSTICK \fP\fP
A virtual joystick\&. This is mainly used by the API\&. 
.TP
\fB\fIPERIPHERAL_TYPE_CAN_INTERFACE \fP\fP
A CAN interface on the main board\&. 
.PP
.nf
134 {
135     PERIPHERAL_TYPE_NONE = 0,               
136     PERIPHERAL_TYPE_ANY = 1,                
137     PERIPHERAL_TYPE_ACTUATORK01 = 100,      
138     PERIPHERAL_TYPE_FINGERK01 = 200,        
139     PERIPHERAL_TYPE_JOYSTICK = 300,         
140     PERIPHERAL_TYPE_VIRTUAL_JOYSTICK = 301, 
141     PERIPHERAL_TYPE_CAN_INTERFACE = 400,    
142 };
.fi
.SS "enum \fBPOSITION_TYPE\fP"

.PP
That represents the type of a position\&. If used during a trajectory, the type of position will change the behaviour of the robot\&. For example if the position type is CARTESIAN_POSITION, then the robot's end effector will move to that position using the inverse kinematics\&. But if the type of position is CARTESIAN_VELOCITY then the robot will use the values as velocity command\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fINOMOVEMENT_POSITION \fP\fP
Used for initialisation\&. 
.TP
\fB\fICARTESIAN_POSITION \fP\fP
A cartesian position described by a translation X, Y, Z and an orientation ThetaX, thetaY and ThetaZ\&. 
.TP
\fB\fIANGULAR_POSITION \fP\fP
An angular position described by a value for each actuator\&. 
.TP
\fB\fICARTESIAN_VELOCITY \fP\fP
A velocity vector used for velocity control\&. 
.TP
\fB\fIANGULAR_VELOCITY \fP\fP
Used for initialisation\&. 
.TP
\fB\fIANY_TRAJECTORY \fP\fP
Not used\&. 
.TP
\fB\fITIME_DELAY \fP\fP
Position used as a time delay\&. 
.PP
.nf
122 {
123     NOMOVEMENT_POSITION = 0,    
124     CARTESIAN_POSITION = 1,     
125     ANGULAR_POSITION = 2,       
126     CARTESIAN_VELOCITY = 7,     
127     ANGULAR_VELOCITY = 8,       
128     ANY_TRAJECTORY = 11,        
129     TIME_DELAY = 12,            
130 };
.fi
.SS "enum \fBRETRACT_TYPE\fP"

.PP
This describes the retract type the robotical arm\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIRETRACT_TYPE_NORMAL_TO_READY \fP\fP
The robotical arm was in a normal custom position and is going toward the READY position\&. 
.TP
\fB\fIRETRACT_TYPE_READY_STANDBY \fP\fP
The robotical arm is in READY position and is waiting for a command\&. 
.TP
\fB\fIRETRACT_TYPE_READY_TO_RETRACT \fP\fP
The robotical arm was in READY position and is going toward the RETRACTED position\&. 
.TP
\fB\fIRETRACT_TYPE_RETRACT_STANDBY \fP\fP
The robotical arm was in RETRACT position and is waiting for a command\&. 
.TP
\fB\fIRETRACT_TYPE_RETRACT_TO_READY \fP\fP
The robotical arm was in RETRACT position and is going toward the READY position\&. 
.TP
\fB\fIRETRACT_TYPE_NORMAL_STANDBY \fP\fP
The robotical arm is initialized and is anywhere in the workspace but it is not retracted, in READY position or between\&. 
.TP
\fB\fIRETRACT_TYPE_NOT_INITIALIZED \fP\fP
The robotical arm is not initialized\&. 
.PP
.nf
247 {
251      RETRACT_TYPE_NORMAL_TO_READY = 0,
252 
256        RETRACT_TYPE_READY_STANDBY = 1,
257 
261     RETRACT_TYPE_READY_TO_RETRACT = 2,
262 
266      RETRACT_TYPE_RETRACT_STANDBY = 3,
267 
271     RETRACT_TYPE_RETRACT_TO_READY = 4,
272 
276       RETRACT_TYPE_NORMAL_STANDBY = 5,
277 
281      RETRACT_TYPE_NOT_INITIALIZED = 6
282 };
.fi
.SS "enum \fBShapeType\fP"

.PP
This represents the type of a 3d shape\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIPrismSquareBase_X \fP\fP
Not used for now\&. 
.TP
\fB\fIPrismSquareBase_Y \fP\fP
Not used for now\&. 
.TP
\fB\fIPrismSquareBase_Z \fP\fP
A rectangular prism\&. 
.TP
\fB\fIPrismTriangularBase_X \fP\fP
Not used for now\&. 
.TP
\fB\fIPrismTriangularBase_Y \fP\fP
Not used for now\&. 
.TP
\fB\fIPrismTriangularBase_Z \fP\fP
Not used for now\&. 
.TP
\fB\fIPyramid \fP\fP
Not used for now\&. 
.PP
.nf
1584 {
1588     PrismSquareBase_X = 0,
1589 
1593     PrismSquareBase_Y = 1,
1594 
1598     PrismSquareBase_Z = 2,
1599 
1603     PrismTriangularBase_X = 3,
1604 
1608     PrismTriangularBase_Y = 4,
1609 
1613     PrismTriangularBase_Z = 5,
1614 
1618     Pyramid = 6
1619 };
.fi
.SH "Variable Documentation"
.PP 
.SS "const int ADDRESS_PAGE_SIZE = 4"

.PP
This represents the size of a page's address\&. 
.SS "const unsigned short PACKET_PER_PAGE_QTY = 40"

.PP
This represents the quantity of USB packet stored in a memory page\&. 
.SS "const unsigned short PAGE_SIZE = 2048"

.PP
This represents the size of a memory page used to program the robot\&. 
.SS "const int PAGEPACKET_SIZE = 52"

.PP
That represents the data's size of each USB packet during firmware update\&. 
.SS "const int USB_DATA_SIZE = 56"

.PP
That represents the data's size of a normal USB packet\&. 
.SS "const int USB_HEADER_SIZE = 8"

.PP
That represents the size of a USB packet's header\&. 
.SH "Author"
.PP 
Generated automatically by Doxygen for Kinova-ROS from the source code\&.
